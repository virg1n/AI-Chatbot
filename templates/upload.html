{% extends "base.html" %}
{% block title %}Upload Images{% endblock %}
{% block head %}
  <link rel="stylesheet" href="{{ url_for('static', filename='css/demo_cosmo.css') }}">
  <style>
    body.upload { background: #0b1220; }
    #uploadBox {
      background: #fff; border-radius: 12px; padding: 30px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1); text-align: center;
      max-width: 800px; margin: 24px auto;
    }
    #fileInput { display: block; margin: 20px auto; font-size: 1rem; }
    .file-list { text-align: left; margin: 12px 0 18px; display: grid; gap: 12px; }
    .file-row { border: 1px solid #e5e5e5; border-radius: 8px; padding: 10px; background: #fafafa; }
    .file-name { font-weight: 600; margin-bottom: 6px; }
    .file-desc {
      width: 100%; padding: 8px 10px; border: 1px solid #ccc; border-radius: 6px;
      resize: vertical; min-height: 48px; font-size: 0.95rem; font-family: inherit;
    }
    .helper { color: #444; margin: 8px 0; }
    #uploadBtn {
      background-color: #0078d7; color: #fff; border: none;
      padding: 10px 25px; border-radius: 8px; cursor: pointer; font-size: 1rem;
    }
    #uploadBtn:hover { background-color: #005fa3; }
    #log {
      margin-top: 25px; text-align: left; background: #fff; padding: 15px;
      border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      max-height: 300px; overflow-y: auto; font-family: monospace; font-size: .9em;
    }
    .success { color: green; }
    .error { color: red; }
    .pending { color: #555; }
  </style>
{% endblock %}
{% block bodyclass %}upload{% endblock %}

{% block content %}
  <nav>
    <ul>
      <li><a href="{{ url_for('home') }}">search</a></li>
    </ul>
  </nav>

  <h1 style="color: white; text-align:center;">Upload Images to Vector Database</h1>

  <div id="uploadBox">
    <input type="file" id="fileInput" accept="image/*" multiple>
    <div class="helper">After selecting files, add an optional description for each (names only, no preview).</div>
    <div id="fileList" class="file-list"></div>
    <button id="uploadBtn" type="button">Upload &amp; Embed</button>
    <div id="log"></div>
  </div>

  <nav class="footer-links">
    <a href="{{ url_for('james_kb') }}">James KB</a>
    <a href="{{ url_for('manage_images') }}">Manage images</a>
  </nav>
{% endblock %}

{% block scripts %}
<script>
  // Same-origin API to avoid CORS:
  const API_URL = "/ingest-image";

  const fileInput = document.getElementById("fileInput");
  const uploadBtn = document.getElementById("uploadBtn");
  const fileListDiv = document.getElementById("fileList");
  const logDiv = document.getElementById("log");

  function renderFileList() {
    fileListDiv.innerHTML = "";
    const files = Array.from(fileInput.files || []);
    if (!files.length) {
      const p = document.createElement("p");
      p.className = "helper";
      p.textContent = "No files selected.";
      fileListDiv.appendChild(p);
      return;
    }
    files.forEach((file, idx) => {
      const row = document.createElement("div");
      row.className = "file-row";

      const name = document.createElement("div");
      name.className = "file-name";
      name.textContent = `${idx + 1}. ${file.name}`;

      const desc = document.createElement("textarea");
      desc.className = "file-desc";
      desc.placeholder = `Description for ${file.name} (optional)`;
      desc.rows = 2;
      desc.dataset.filename = file.name;

      row.appendChild(name);
      row.appendChild(desc);
      fileListDiv.appendChild(row);
    });
  }

  function collectDescriptions() {
    const map = new Map();
    fileListDiv.querySelectorAll(".file-desc").forEach((el) => {
      map.set(el.dataset.filename, (el.value || "").trim());
    });
    return map;
  }

  function makeLogLine(fileName, text, className = "pending") {
    const line = document.createElement("div");
    line.className = className;
    line.innerHTML = text;
    line.dataset.file = fileName;
    logDiv.appendChild(line);
    return line;
  }

  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  async function uploadOne(file, lineEl, { timeoutMs = 60000, maxRetries = 3, description }) {
    const formData = new FormData();
    formData.append("image", file, file.name);
    if (description) {
      formData.append("description", description);
    }

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);

      try {
        const res = await fetch(API_URL, { method: "POST", body: formData, signal: controller.signal });
        const text = await res.text();
        let data = null; try { data = JSON.parse(text); } catch {}

        if (!res.ok) {
          const transient = [408, 429, 500, 502, 503, 504].includes(res.status);
          if (transient && attempt < maxRetries) {
            const delay = 500 * Math.pow(2, attempt);
            lineEl.className = "pending";
            lineEl.textContent = `↻ ${file.name}: transient ${res.status}. Retrying in ${delay}ms...`;
            await sleep(delay);
            continue;
          }
          lineEl.className = "error";
          lineEl.textContent = `❌ ${file.name}: ${res.status} ${res.statusText} — ${text.slice(0,200)}`;
          return;
        }

        if (data && data.error) {
          lineEl.className = "error";
          lineEl.textContent = `❌ ${file.name}: ${data.error}`;
        } else if (data) {
          lineEl.className = "success";
          const descLine = data.description ? `<br>Description: <code>${data.description}</code>` : "";
          lineEl.innerHTML = `✅ ${file.name} uploaded!<br>ID: <code>${data.id ?? "n/a"}</code><br>Saved path: <code>${data.path ?? "n/a"}</code>${descLine}`;
        } else {
          lineEl.className = "success";
          lineEl.textContent = `✅ ${file.name} uploaded (no JSON body).`;
        }
        return;
      } catch (err) {
        if (attempt < maxRetries) {
          const delay = 500 * Math.pow(2, attempt);
          lineEl.className = "pending";
          lineEl.textContent = `↻ ${file.name}: ${err.name || "Error"} — retrying in ${delay}ms...`;
          await sleep(delay);
          continue;
        }
        lineEl.className = "error";
        lineEl.textContent = `❌ ${file.name}: ${err.message}`;
        return;
      } finally {
        clearTimeout(timer);
      }
    }
  }

  async function uploadMany(files, concurrency = 1) {
    const descriptionMap = collectDescriptions();
    const queue = Array.from(files).map(file => {
      const line = makeLogLine(file.name, `Uploading ${file.name}...`);
      return { file, line };
    });

    let index = 0;
    const workers = new Array(Math.min(concurrency, queue.length)).fill(0).map(async () => {
      while (true) {
        const i = index++;
        if (i >= queue.length) break;
        const current = queue[i];
        const description = descriptionMap.get(current.file.name) || "";
        await uploadOne(current.file, current.line, { timeoutMs: 120000, maxRetries: 3, description });
      }
    });

    await Promise.all(workers);
  }

  uploadBtn.addEventListener("click", async (event) => {
    event.preventDefault();
    const { files } = fileInput;
    if (!files || files.length === 0) {
      alert("Please select one or more images to upload.");
      return;
    }
    logDiv.innerHTML = "";
    uploadBtn.disabled = true;
    uploadBtn.textContent = "Uploading...";
    try {
      await uploadMany(files, 1);
    } finally {
      uploadBtn.disabled = false;
      uploadBtn.textContent = "Upload & Embed";
    }
  });

  fileInput.addEventListener("change", renderFileList);
  renderFileList();
</script>
{% endblock %}
